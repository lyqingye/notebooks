## å¯¹beançš„åŒ…è£…

### 1.å‰è¨€

ä¸ºä»€ä¹ˆå…ˆä»å¯¹beançš„åŒ…è£…å¼€å§‹é˜…è¯»æºç å‘¢ï¼Œå› ä¸ºbeansåŒ…çš„æ ¸å¿ƒå°±æ˜¯`BeanFactory` ğŸ¶ï¼Œå…¶ä½œç”¨å°±æ˜¯å¯¹beanè¿›è¡Œç®¡ç†ï¼Œé‚£ä¹ˆå¯¹beanç®¡ç†çš„å‰æå°±æ˜¯å¯¹beanè¿›è¡Œè§£æï¼Œç„¶åæ”¯æŒå±æ€§çš„`set` æˆ– `get` æ“ä½œã€‚é‚£ä¹ˆæˆ‘ä»¬åˆ—ä¸¾ä¸€ä¸‹`BeanFactory`çš„ä¸»è¦èŒè´£ï¼Œå³ä½¿æ²¡é˜…è¯»è¿‡æºç ï¼Œä¹Ÿåº”è¯¥çŸ¥é“ä¸ªå¤§æ¦‚è¿‡ç¨‹.

+ è§£æ`xml`æˆ–è€…å…¶å®ƒé…ç½®æ–‡ä»¶å¾—åˆ° `BeanDefinition`
+ å®ä¾‹åŒ– `Instance`
+ `AutoWired`è‡ªåŠ¨è£…é… `Bean`çš„ä¾èµ–

**æ‰€ä»¥ï¼Œæˆ‘ä»¬å…ˆäº†è§£å¦‚ä½•å»å¾—åˆ°ä¸€ä¸ªBeançš„ â€œå®šä¹‰â€ (è§£æxmlé‚£éƒ¨åˆ†å…ˆä¸è®²)**

### 2. `BeanWrapper` 

```tex
è¿™ä¸ªç±»çš„ä¸»è¦ä½œç”¨æ˜¯è§£æ`Class` ç„¶åè·å–å±æ€§ï¼Œè¿›ä¸€æ­¥å°è£…ï¼Œç„¶åæä¾›ä¿®æ”¹å±æ€§çš„æ¥å£
```

```java
public interface BeanWrapper extends ConfigurablePropertyAccessor {
  // è®¾ç½®é›†åˆå±æ€§è‡ªå¢é•¿çš„é•¿åº¦
	void setAutoGrowCollectionLimit(int autoGrowCollectionLimit);
	
  // è·å–å½“å‰é›†åˆå±æ€§è‡ªå¢é•¿çš„é•¿åº¦
	int getAutoGrowCollectionLimit();
	
	// è·å–åŒ…è£…çš„Beançš„Instance
	Object getWrappedInstance();
	
	// è·å–Beançš„Class
	Class<?> getWrappedClass();
	
	// è·å–æ‰€æœ‰å±æ€§æè¿°ç¬¦
	PropertyDescriptor[] getPropertyDescriptors();
  
  // è·å–å±æ€§æè¿°ç¬¦
	PropertyDescriptor getPropertyDescriptor(String propertyName) throws InvalidPropertyException;

}
```



ä¸ºä»€ä¹ˆä¸Šé¢ä¼šæ¶‰åŠåˆ°**é›†åˆ**ï¼Œå› ä¸º`Bean` æ”¯æŒ`nested (åµŒå¥—)` å±æ€§è¯»å†™ï¼Œä¹Ÿå°±æ˜¯`pojo`

```properties
bean.setValue("bean.child.attr", 1)
```

### 3. ä¸‹é¢çœ‹ä¸€ä¸‹`BeanWrapper`çš„å®ç°ç±»ï¼Œ`BeanWrapperImpl`

1. æˆ‘ä»¬ä»å…¶æµ‹è¯•ä»£ç ä¸­å¯ä»¥çœ‹åˆ°è¿™æ ·çš„ç”¨æ³•

   

   ```java
   GetterBean target = new GetterBean();
   BeanWrapper accessor = createAccessor(target);
   accessor.setPropertyValue("name", "tom");
   assertThat(target.getAliasedName()).isEqualTo("tom");
   assertThat(accessor.getPropertyValue("aliasedName")).isEqualTo("tom");
   ```

   ```java
   protected BeanWrapperImpl createAccessor(Object target) {
   		return new BeanWrapperImpl(target);
   	}
   ```

   æˆ‘ä»¬å¯ä»¥çœ‹åˆ° `createAccessor` å°±æ˜¯`new BeanWrapperImpl`å°±å®Œæˆå¯¹`Bean`çš„å°è£…äº†ï¼Œ å°±å¯ä»¥è°ƒç”¨

   - `setPropertyValue`  è®¾ç½®å±æ€§å€¼
   - `getPropertyValue`  è·å–å±æ€§å€¼

2. åˆæ­¥çœ‹ä¸‹ `BeanWrapperImpl`çš„`UML` (ä¸ç”¨çº ç»“ `UML` åé¢ä¼šäººè‚‰å…¶è¿è¡Œè¿‡ç¨‹) :happy:

   

   ![image-20191012223223606](assert/image-20191012223223606.png)

   
   
   **åœ¨ä¸Šé¢è¿™ä¸ªå›¾ä¸­ï¼Œç€é‡ `AbstractNesablePropertyAccessor`** æ­¤ç±»æ˜¯ç”¨äºæ”¯æŒä¸Šæ–‡æåˆ°çš„`Nested` åµŒå¥—å±æ€§è¯»å†™.
   
3. `getPropertyDescriptor` è·å–å±æ€§æè¿°ç¬¦

   ```java
   public PropertyDescriptor getPropertyDescriptor(String propertyName) throws InvalidPropertyException {
   		// [1] å…ˆè§£æåµŒå¥—å±æ€§ï¼Œè·å–æœ€åä¸€ä¸ªå±æ€§çš„Instance
   		BeanWrapperImpl nestedBw = (BeanWrapperImpl) getPropertyAccessorForPropertyPath(propertyName);
   		String finalPath = getFinalPath(nestedBw, propertyName);
   		// [2] ç„¶åç›´æ¥è·å–å±æ€§æè¿°ç¬¦
   		PropertyDescriptor pd = nestedBw.getCachedIntrospectionResults().getPropertyDescriptor(finalPath);
   		if (pd == null) {
   			throw new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,
   					"No property '" + propertyName + "' found");
   		}
   		return pd;
   	}
   ```

   + åˆšæ‰æˆ‘ä»¬è¯´è¿‡å…¶æ”¯æŒ`nested` åµŒå¥—å±æ€§ï¼Œå¦‚æœæˆ‘ä»¬ä¼ å…¥çš„`propertyName` ä¸º `bean.child.name` ï¼Œæˆ‘ä»¬å°±è¦å…ˆæ‹¿åˆ° `bean` ç„¶åå†æ‹¿åˆ° `child` æœ€åæ‹¿åˆ° `name` ç„¶åæ‰èƒ½è¿”å›ç±»å‹æè¿°ç¬¦. â€‹ :warning: ç¬¬ä¸€æ­¥æˆ‘ä»¬å…ˆä¸ç®¡

   + ç„¶åç¬¬äºŒæ­¥ `getCachedIntrospectionResults#getPropertyDescriptor()` æ¥è·å–å±æ€§æè¿°ç¬¦

   + `CachedIntrospectionResults` ä¸­åŒ…å« `PropertyDescriptor` ä¿¡æ¯ï¼Œè·Ÿä¸‹å»

     

     ```java
     private CachedIntrospectionResults getCachedIntrospectionResults() {
        	// [1] åˆ¤æ–­æ˜¯ä¸æ˜¯æœ‰ç¼“å­˜äº†
     		if (this.cachedIntrospectionResults == null) {
           // [2] ç¼“å­˜ä¸­æ²¡æœ‰é‚£å°± new
     			this.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());
     		}
     		return this.cachedIntrospectionResults;
     	}
     ```

     ç»§ç»­è·Ÿã€‚

     ```java
     static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {
     		// [1] ä»ä¸€çº§ç¼“å­˜ä¸­è·å–
     		CachedIntrospectionResults results = strongClassCache.get(beanClass);
     		if (results != null) {
     			return results;
     		}
     
     		// [2] ä»äºŒçº§ç¼“å­˜ä¸­è·å–
     		results = softClassCache.get(beanClass);
     		if (results != null) {
     			return results;
     		}
     
     		// [3] å¦‚æœéƒ½æ²¡æœ‰ï¼Œåˆ™Newä¸€ä¸ª, æ ¸å¿ƒè¿˜æ˜¯åœ¨è¿™
     		results = new CachedIntrospectionResults(beanClass);
     		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse;
     
     		// [4] åˆ¤æ–­ä½¿ç”¨ä¸€çº§ç¼“å­˜è¿˜æ˜¯äºŒçº§ç¼“å­˜
     		// ç»è°ƒè¯•ï¼Œå‘ç°springç”¨çš„æ˜¯ä¸€çº§ç¼“å­˜
     		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||
     				isClassLoaderAccepted(beanClass.getClassLoader())) {
     			classCacheToUse = strongClassCache;
     		}
     		else {
     			if (logger.isDebugEnabled()) {
     				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe");
     			}
     			classCacheToUse = softClassCache;
     		}
     
     		// [5] å°†æ–°Newçš„æ”¾å…¥ç¼“å­˜
     		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results);
     		return (existing != null ? existing : results);
     	}
     ```

     å¯ä»¥çœ‹åˆ°`spring` å¾ˆå–„ç”¨ç¼“å­˜ï¼Œè¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œå…¶ç”¨äº†ä¸¤ä¸ªç¼“å­˜ `strongClassCache` å’Œ `softClassCache`

     ```java
       /* [DESC] ä¸€çº§ç¼“å­˜*/
     	static final ConcurrentMap<Class<?>, CachedIntrospectionResults> strongClassCache =
     			new ConcurrentHashMap<>(64);
     
     	/* [DESC] äºŒçº§ç¼“å­˜ åˆç§°ä¸º SoftCacheï¼Œå› ä¸ºé‡‡ç”¨å¼±å¼•ç”¨MAPï¼Œæ‰€ä»¥ç¼“å­˜å…ƒç´ é•¿æ—¶é—´æœªä½¿ç”¨åˆ™ä¼šè¢«å›æ”¶*/
     	static final ConcurrentMap<Class<?>, CachedIntrospectionResults> softClassCache =
     			new ConcurrentReferenceHashMap<>(64);
     ```

     **è™½ç„¶å…¶è®¾ç½®äº†ä¸¤å±‚ç¼“å­˜ï¼Œä½†å®é™…åªç”¨åˆ°äº† `strongClassCache`** å› ä¸ºå±æ€§è¿™äº›ä¼šå¸¸é©»å†…å­˜ï¼Œæ‰€ä»¥ä¸éœ€è¦ä½¿ç”¨å¼±å¼•ç”¨çš„`Map`,å®é™…ä¸Šæ§åˆ¶ä½¿ç”¨é‚£ä¸ªç¼“å­˜æ˜¯`isCacheSafe` æ¥æ§åˆ¶çš„, ç»§ç»­è·Ÿ :hammer:æˆ‘æ˜¯æœ€å¼ºäººè‚‰ç‹å­

     ```java
     public static boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader) {
        Assert.notNull(clazz, "Class must not be null");
        try {
           // [1] è·å–è¯¥ç±»çš„ClassLoader
           ClassLoader target = clazz.getClassLoader();
           // Common cases
     
           // [2] å¦‚æœç›®æ ‡ç±»çš„ClassLoader == æä¾›çš„classLoader
           // [NOTICE] åŒäº²å§”æ´¾åŸåˆ™ï¼Œåªæœ‰ä½¿ç”¨åŒä¸€ä¸ªç±»åŠ è½½å™¨ï¼ŒåŠ è½½çš„æ•°æ®æ‰èƒ½æ˜¯åªæœ‰ä¸€ä»½ï¼Œè¿™ä¸ªç¼“å­˜æ‰æ˜¯æ˜¯æœ‰æ•ˆçš„
           if (target == classLoader || target == null) {
              return true;
           }
           if (classLoader == null) {
              return false;
           }
           // [3] é€’å½’classLoaderçš„ç¥–å…ˆ
           // Check for match in ancestors -> positive
           ClassLoader current = classLoader;
           while (current != null) {
              current = current.getParent();
              if (current == target) {
                 return true;
              }
           }
           
           // [4] é€’å½’ç›®æ ‡çš„ç¥–å…ˆ
           // Check for match in children -> negative
           while (target != null) {
              target = target.getParent();
              if (target == classLoader) {
                 return false;
              }
           }
        }
        catch (SecurityException ex) {
           // Fall through to loadable check below
        }
     
        // Fallback for ClassLoaders without parent/child relationship:
        // safe if same Class can be loaded from given ClassLoader
        return (classLoader != null && isLoadable(clazz, classLoader));
     }
     ```

     **è¿™é‡Œåˆ¤æ–­cacheæ˜¯å¦å®‰å…¨çš„åŸç†æ˜¯** ï¼Œæ ¹æ®`åŒäº²å§”æ´¾` æœºåˆ¶ï¼Œå› ä¸ºä¸€ä¸ªç±»è¢«ä¸€ä¸ªåŠ è½½å™¨åŠ è½½ä¸€æ¬¡åœ¨å†…å­˜ä¸­å°±ä¼šæœ‰ä¸€ä»½`Class` , å¦‚æœå®ƒä»¬çš„åŠ è½½å™¨æ˜¯ä¸€æ ·çš„ï¼Œé‚£ä¹ˆå¾—åˆ°çš„`Class` ä¹Ÿæ˜¯ä¸€è‡´çš„ï¼Œè¿™æ ·æ‰èƒ½ç¡®ä¿ï¼Œæˆ‘ä»¬æ‹¿åˆ°çš„ç›®æ ‡`Class` æ•°æ®æ˜¯æ­£ç¡®çš„ã€‚

     è§£æå®Œè¿™ä¸ªï¼Œæˆ‘ä»¬ç»§ç»­ä¸Šé¢çš„ï¼Œå¦‚æœä»ç¼“å­˜æ‹¿ä¸åˆ°åˆ™ `new`

     ```java
     results = new CachedIntrospectionResults(beanClass);
     ```

     ```java
     private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {
     		try {
     			if (logger.isTraceEnabled()) {
     				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]");
     			}
     			// å…³æ³¨ #getBeanInfo
     			this.beanInfo = getBeanInfo(beanClass);
     ```

     ```java
     private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException {
        // [1] å°è¯•ä»åŠ è½½çš„å·¥å‚ä¸­è·å–BeanInfo
        // å®é™…ä¸Šï¼Œspring.beans åªæä¾›ä¸€ä¸ªå·¥å‚ï¼Œè€Œä¸”é‚£ä¸ªå·¥å‚ä¹Ÿæ˜¯ä»çº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­è·å–
        // æ‰€ä»¥ä¸€å®šèƒ½æ‹¿åˆ°ï¼Œè¿™æ˜¯ä¸ºäº†é˜²æ­¢spring.beansæ²¡æœ‰æä¾›å·¥å‚è€Œè€ƒè™‘åˆ°çš„ç»†èŠ‚
        for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {
           BeanInfo beanInfo = beanInfoFactory.getBeanInfo(beanClass);
           if (beanInfo != null) {
              return beanInfo;
           }
        }
     
        // [2] å¦‚æœä¸æä¾›å·¥å‚æˆ–è€…å·¥å‚ä¸å­˜åœ¨ï¼Œç›´æ¥åœ¨çº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­è·å–
        return (shouldIntrospectorIgnoreBeaninfoClasses ?
              Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :
              Introspector.getBeanInfo(beanClass));
     }
     ```

     åœ¨`CachedIntrospectionResults` ä¸­ï¼Œå®ƒä¼šåŠ è½½ä¸€ä¸ª `factory`

     ```java
     /** [DESC]  åœ¨è¿™é‡ŒåŠ è½½BeanInfoFactory*/
     // åŠ è½½ "META-INF/spring.factories" ä¸­æŒ‡å®šçš„å·¥å‚ç±»
     private static List<BeanInfoFactory> beanInfoFactories = SpringFactoriesLoader.loadFactories(
           BeanInfoFactory.class, CachedIntrospectionResults.class.getClassLoader());
     ```

     ```properties
     org.springframework.beans.BeanInfoFactory=org.springframework.beans.ExtendedBeanInfoFactory
     ```

     å‘ç°äº†ï¼Œå®ƒçš„é»˜è®¤å·¥å‚ç±»æ˜¯ `ExtendedBeanInfoFactory`

     æ¥ä¸‹æ¥ç»§ç»­çœ‹ï¼Œå¦‚æœå·¥å‚ç±»ä¸­ä¸å­˜åœ¨ `BeanInfo`åˆ™ä¼šè°ƒç”¨ `Introspector#getBeanInfo()`

     ```java
     public static BeanInfo getBeanInfo(Class<?> beanClass)
             throws IntrospectionException
         {
             if (!ReflectUtil.isPackageAccessible(beanClass)) {
                 return (new Introspector(beanClass, null, USE_ALL_BEANINFO)).getBeanInfo();
             }
       			// ä»çº¿ç¨‹ä¸Šä¸‹æ–‡è·å–å·²ç»åŠ è½½çš„ Class ä¿¡æ¯
             ThreadGroupContext context = ThreadGroupContext.getContext();
             BeanInfo beanInfo;
             synchronized (declaredMethodCache) {
                 beanInfo = context.getBeanInfo(beanClass);
             }
             if (beanInfo == null) {
                 beanInfo = new Introspector(beanClass, null, USE_ALL_BEANINFO).getBeanInfo();
                 synchronized (declaredMethodCache) {
                     context.putBeanInfo(beanClass, beanInfo);
                 }
             }
             return beanInfo;
         }
     ```

     åˆ°æ­¤å°±ä¸ç”¨è¿½äº†ï¼Œè¿™é‡Œå·²ç»æ˜¯jdkäº†ï¼Œå®é™…ä¸Šæ˜¯ä» `çº¿ç¨‹ä¸Šä¸‹æ–‡`è·å–çš„ `BeanInfo` ï¼Œè¿™ä¹Ÿè¯æ˜äº† `BeanFactory` ç”¨çš„æ˜¯ `çº¿ç¨‹ä¸Šä¸‹æ–‡åŠ è½½å™¨` 

     **å…¶å®ä¸Šé¢çš„ é»˜è®¤å·¥å‚ ExtendedBeanInfoFactory** ç”¨çš„ä¹Ÿæ˜¯`ä¸Šä¸‹æ–‡åŠ è½½å™¨`

     ```java
     public class ExtendedBeanInfoFactory implements BeanInfoFactory, Ordered {
     
        /**
         * Return an {@link ExtendedBeanInfo} for the given bean class, if applicable.
         */
        @Override
        @Nullable
        public BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException {
           return (supports(beanClass) ? new ExtendedBeanInfo(Introspector.getBeanInfo(beanClass)) : null);
        }
     ```

     **æ€»ç»“ä¸‹ï¼Œä»¥å…è·Ÿå¾—å¤ªæ·±ï¼Œå›æº¯ä¸äº†**

     ![image-20191013012133042](./assert/image-20191013012133042.png)

     

     **ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¹Ÿåªæ˜¯æ‹¿åˆ°äº† `BeanInfo`**

     å›åˆ° `new CachedIntrospectionResults` çš„åœ°æ–¹ï¼Œæˆ‘ä»¬é¦–å…ˆå·²ç»æœ‰äº† `BeanInfo`

     ```java
     private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {
        try {
           // å…³æ³¨ #getBeanInfo
           this.beanInfo = getBeanInfo(beanClass);
     
           this.propertyDescriptorCache = new LinkedHashMap<>();
     
           // [1] ç›´æ¥è·å–BeanInfoçš„ {@link PropertyDescriptor}
           PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors();
           for (PropertyDescriptor pd : pds) {
              // [2] æŸäº›å±æ€§æ˜¯è¢«ä¿æŠ¤çš„ï¼Œåˆ™è·³è¿‡
              if (Class.class == beanClass &&
                    ("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {
                 continue;
              }
              // [3] å°†{@link PropertyDescriptor} è½¬æ¢ä¸º {@link GenericTypeAwarePropertyDescriptor}
              pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);
              // [4] ä¸¢å…¥ç¼“å­˜
              this.propertyDescriptorCache.put(pd.getName(), pd);
           }
     
           // [5] è¿˜å¾—åˆ¤æ–­è¿™äº›æ–¹æ³•æ˜¯ä¸æ˜¯java8çš„æ¥å£çš„é»˜è®¤æ–¹æ³•
           Class<?> currClass = beanClass;
           while (currClass != null && currClass != Object.class) {
              introspectInterfaces(beanClass, currClass);
              currClass = currClass.getSuperclass();
           }
           this.typeDescriptorCache = new ConcurrentReferenceHashMap<>();
        }
        
     }
     ```

     ç›´æ¥ä» `BeanInfo` æ‹¿åˆ°å±æ€§æè¿°ç¬¦ï¼Œå¹¶ä¸”ç¼“å­˜èµ·æ¥ï¼Œç°åœ¨æˆ‘ä»¬å°±å®Œæˆäº†è·å– `BeanInfo` éƒ¨åˆ†äº†ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„å°±æ˜¯æ ¹æ®æ‹¿åˆ°çš„ `PropertyDescriptor` å»è¯»å†™ `Property` :wink:

4. `getPropertyAccessorForPropertyPath`

   åœ¨ä¸Šé¢çš„`getPropertyDescriptor`ä¸­ç”¨åˆ°äº†è¿™ä¸ªæ–¹æ³•å»è§£æ `nested` åµŒå¥—å±æ€§ï¼Œä¸‹é¢å°±æ¥çœ‹ä¸‹å®ƒæ€ä¹ˆå®ç°çš„

   é¦–å…ˆæˆ‘ä»¬å¾—æ˜ç¡®ä¸€ä»¶äº‹æƒ…ï¼Œ`BeanWrapperImp` ç»§æ‰¿è‡ª `AbstractNestablePropertyAccessor` å› ä¸º `BeanWrapperImp` æºå¸¦æœ‰ `Instance` ï¼Œæ‰€ä»¥ `AbstractNestablePropertyAccessor` å¿…ç„¶ä¹Ÿæºå¸¦æœ‰ `Instance` ï¼Œé‚£æŒ‰ç…§æˆ‘ä»¬çš„æ€è·¯è¯¥å¦‚ä½•è§£æ `nested` å±æ€§å‘¢ï¼Œæ¯”å¦‚ æœ‰ä¸€ä¸ª`Bean`

   ```java
   class Student{
     private name;
     private Clazz clazzInfo;
   }
   class Clazz{
     private Integer id;
   }
   ```

   è¿™ä¸ªæˆ‘ä»¬éœ€è¦å–å‡ºå…¶`ClazzId`ï¼Œç”¨`nested` è¡¨ç¤ºå°±æ˜¯ `clazzInfo.id` ï¼Œé‚£æˆ‘ä»¬è¯¥å¦‚ä½•è§£æï¼Œé¦–å…ˆæ‰¾åˆ°ç¬¬ä¸€ä¸ªå±æ€§

   `clazzInfo`ï¼Œç„¶åä»`Student`ä¸­è·å– `clazzInfo` çš„`Instance` ï¼Œç„¶ååœ¨è§£æç¬¬äºŒä¸ªå±æ€§ `id` ï¼Œç„¶åå†åœ¨`classInfo` ä¸­æ‹¿åˆ° `id` çš„å€¼ï¼Œè¿™æ˜¾ç„¶æ˜¯ä¸€ä¸ªé€’å½’ã€‚

   ä¸‹é¢æ¥çœ‹å®ç°:

   ```java
   protected AbstractNestablePropertyAccessor getPropertyAccessorForPropertyPath(String propertyPath) {
      // [1] è§£æå‡ºç¬¬ä¸€ä¸ªå±æ€§çš„åˆ†å‰²ç´¢å¼•
      int pos = PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex(propertyPath);
    
   ```

   **é¦–å…ˆçœ‹ç¬¬ä¸€æ­¥**ï¼š`PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex`

   ```java
   private static int getNestedPropertySeparatorIndex(String propertyPath, boolean last) {
      // [1] map[my.key] è¿™ç§å°±æ— æ³•è§£æï¼Œå› ä¸ºå®ƒæ˜¯æŒ‰é¡ºåºè§£æçš„
      // å¦‚æœå±æ€§æ˜¯ä¸€ä¸ªæ•°ç»„ value[1].xï¼Œå®ƒå°±è§£æå‡º value[1]
      boolean inKey = false;
      int length = propertyPath.length();
      int i = (last ? length - 1 : 0);
      while (last ? i >= 0 : i < length) {
         switch (propertyPath.charAt(i)) {
             // "["
            case PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR:
             // "]"
            case PropertyAccessor.PROPERTY_KEY_SUFFIX_CHAR:
               // å¿½ç•¥[.] ä¸­çš„ dots
               inKey = !inKey;
               break;
             // "."
            case PropertyAccessor.NESTED_PROPERTY_SEPARATOR_CHAR:
             // ç¡®ä¿è¿™ä¸ª "." ä¸æ˜¯åœ¨ [] é‡Œé¢
               if (!inKey) {
                  // ä¸åœ¨[]é‡Œé¢çš„ . è¯´æ˜å°±æ‰¾åˆ°äº†åˆ†éš”ç¬¦
                  return i;
               }
         }
         if (last) {
            i--;
         }
         else {
            i++;
         }
      }
      return -1;
   }
   ```

   å¯ä»¥çœ‹å‡º`nested`ä¸ä»…æ”¯æŒ`æ™®é€šç±»å‹`å’Œ`pojo` ï¼Œè¿˜æ”¯æŒ `map` å’Œ `list` é›†åˆï¼Œä½†æ”¯æŒåº¦æœ€ç»ˆæœ‰é™ï¼Œæ¯”å¦‚è¯´è¿™ç§å½¢å¼å®ƒå°±ä¸æ”¯æŒ `map[child.name]` , `[]` ä¸­å¸¦ `.` æ˜¯ä¸æ”¯æŒçš„ã€‚ 

   ä»ä¸Šé¢å¯ä»¥çœ‹å‡ºï¼Œå…¶é‡åˆ° `.` å°±ç›´æ¥è¿”å›äº†ï¼Œæ‰€ä»¥è¯´ å½“æˆ‘ä»¬è¾“å…¥ `child[1].name` å’Œ `child.name` ï¼Œå®ƒè¿”å›çš„éƒ½æ˜¯ `.`çš„ä½ç½®ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç»§ç»­è·Ÿè¸ªä¸Šé¢.

   ```java
    protected AbstractNestablePropertyAccessor getPropertyAccessorForPropertyPath(String propertyPath) {
      // [1] è§£æå‡ºç¬¬ä¸€ä¸ªå±æ€§çš„åˆ†å‰²ç´¢å¼•
      int pos = PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex(propertyPath);
      if (pos > -1) {
         // [2] è·å–ç¬¬ä¸€ä¸ªå±æ€§å
         String nestedProperty = propertyPath.substring(0, pos);
         // å‰©ä¸‹çš„è·¯å¾„, é€’å½’
         String nestedPath = propertyPath.substring(pos + 1);
         // [3] æ ¹æ®å±æ€§åè·å– accessor
         AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);
         // [4] ç»§ç»­é€’å½’ nested path
         return nestedPa.getPropertyAccessorForPropertyPath(nestedPath);
      }
      else {
         return this;
      }
   }
   ```

   **æ¥ç€çœ‹ç¬¬äºŒæ­¥**ï¼Œå°±æ˜¯æ ¹æ® `.` çš„ä½ç½®åˆ†éš”å‡ºå±æ€§çš„åå­—

   + å¦‚æœè¾“å…¥ `bean[1].name` é‚£ä¹ˆè·å–çš„å±æ€§åå°±åº”è¯¥æ˜¯ `bean[1]`ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„è·¯å¾„å°±æ˜¯`name`äº†; 

   + å¦‚æœè¾“å…¥ `bean.name` ï¼Œé‚£ä¹ˆè·å–çš„å±æ€§åå°±æ˜¯`bean` ï¼Œå‰©ä¸‹çš„è·¯å¾„å°±æ˜¯ `name`

     

   **ç¬¬ä¸‰æ­¥**, æ‹¿åˆ°å±æ€§åæ€ä¹ˆåšï¼Ÿé‚£ä¸å°±æ˜¯è°ƒç”¨ `getProperty` æ‹¿åˆ°`Instance`å—ï¼Œåœ¨è¿™é‡Œå®ƒå°è£…äº†ä¸€ä¸‹ï¼ŒèŒè´£è¿›è¡Œäº†åˆ†ç¦».

   + `AbstractNestablePropertyAccessor` ç”¨äºè§£æå‡º `å±æ€§å`
   + `PropertyHandler` ç”¨äºè¯»å†™`å±æ€§å€¼`
   + `PropertyTokenHolder` å¯¹å±æ€§åè¿›è¡Œå°è£…ï¼Œå› ä¸ºå¦‚æœå±æ€§æ˜¯é›†åˆç±»å‹ `bean[1]` è¿™ä¸ªè¿˜æ˜¯éœ€è¦å†è§£æçš„ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸€ä¸ª `Token` æ¥æè¿°è§£æå‡ºæ¥çš„`å±æ€§`

   äº†è§£äº†èŒè´£åˆ†ç¦»ï¼Œç†è§£èµ·æ¥å°±ç®€å•äº†ï¼Œæˆ‘ä»¬ç»§ç»­ç¬¬ä¸‰æ­¥

   ```java
   AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);
   ```

   ```java
   private AbstractNestablePropertyAccessor getNestedPropertyAccessor(String nestedProperty) {
      if (this.nestedPropertyAccessors == null) {
         this.nestedPropertyAccessors = new HashMap<>();
      }
      // [1] é¦–å…ˆç”Ÿæˆ token
      PropertyTokenHolder tokens = getPropertyNameTokens(nestedProperty);
      String canonicalName = tokens.canonicalName;
   
      // [2] ä»Instanceä¸­è·å–å€¼
      Object value = getPropertyValue(tokens);
   
      // [3] å¦‚æœå€¼ä¸ºç©ºï¼Œåˆ™åˆ¤æ–­æ˜¯ä¸æ˜¯æ”¯æŒé›†åˆç±»å‹çš„æ•°æ®ï¼Œæ˜¯é›†åˆç±»å‹æ•°æ®å°± new ä¸€ä¸ªç©ºé›†åˆ
      if (value == null || (value instanceof Optional && !((Optional<?>) value).isPresent())) {
         if (isAutoGrowNestedPaths()) {
            // è¿™é‡Œè®¾ç½®ä¸€ä¸ªé»˜è®¤å€¼ï¼Œä¹Ÿå°±æ˜¯ new ArrayList æˆ–è€… HashMap
            value = setDefaultValue(tokens);
         }
         else {
            // ä¸æ”¯æŒé›†åˆç±»å‹é‚£å°±æŠ¥å¼‚å¸¸æ´›
            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + canonicalName);
         }
      }
   
      // [4] å°†å…¶Instanceäº¤ç»™ AbstractNestablePropertyAccessor ï¼Œå› ä¸ºå®ƒæ˜¯è´Ÿè´£æ“ä½œInstanceçš„
      // å…ˆå°è¯•ä»ç¼“å­˜ä¸­æ‰¾
      AbstractNestablePropertyAccessor nestedPa = this.nestedPropertyAccessors.get(canonicalName);
      if (nestedPa == null || nestedPa.getWrappedInstance() != ObjectUtils.unwrapOptional(value)) {
         // [5] æ‰¾ä¸åˆ°åˆ™ new ä¸€ä¸ª
         nestedPa = newNestedPropertyAccessor(value, this.nestedPath + canonicalName + NESTED_PROPERTY_SEPARATOR);
   
         // ç»§æ‰¿å±æ€§ç¼–è¾‘å™¨
         copyDefaultEditorsTo(nestedPa);
         copyCustomEditorsTo(nestedPa, canonicalName);
   
         // åˆ«å¿˜è®°ä¸¢è¿›ç¼“å­˜
         this.nestedPropertyAccessors.put(canonicalName, nestedPa);
      }
      return nestedPa;
   }
   ```

   1. æ ¹æ®ä¼ è¿›æ¥çš„å±æ€§ååˆ›å»º`token`

      ```java
      private PropertyTokenHolder getPropertyNameTokens(String propertyName) {
         /**------------------------------------------------------------------------------------------------------------
          * [DESC] å®é™…ç”¨é€”å°±æ˜¯ç”¨æ¥è§£æé›†åˆç±»å‹çš„åµŒå¥—å±æ€§ç„¶åå°è£…æˆtoken
          * 1. bean[1].name
          * 2. bean[1][2].name
          * 3. bean["key"].x
          * 4. bean['key'].y
          *------------------------------------------------------------------------------------------------------------*/
      
         String actualName = null;
         List<String> keys = new ArrayList<>(2);
         int searchIndex = 0;
         while (searchIndex != -1) {
            // [1] å…ˆæ‰¾å‡º [ çš„ä½ç½®
            int keyStart = propertyName.indexOf(PROPERTY_KEY_PREFIX, searchIndex);
            searchIndex = -1;
            if (keyStart != -1) {
               // [2] å†æ‰¾ ] çš„ä½ç½®
               int keyEnd = getPropertyNameKeyEnd(propertyName, keyStart + PROPERTY_KEY_PREFIX.length());
               if (keyEnd != -1) {
                  if (actualName == null) {
                     // [3] è·å–å±æ€§å
                     actualName = propertyName.substring(0, keyStart);
                  }
                  // [4] æŠŠkeyå–å‡ºæ¥ï¼Œå¦‚æœæ˜¯ "key" æˆ–è€… 'key' é‚£å°±æŠŠå‰ç¼€å»æ‰
                  String key = propertyName.substring(keyStart + PROPERTY_KEY_PREFIX.length(), keyEnd);
                  if (key.length() > 1 && (key.startsWith("'") && key.endsWith("'")) ||
                        (key.startsWith("\"") && key.endsWith("\""))) {
                     key = key.substring(1, key.length() - 1);
                  }
                  // æŠŠkeyä¸¢è¿›å»
                  keys.add(key);
      
                  // [5] å› ä¸ºæ”¯æŒå¤šç»´æ•°ç»„ï¼Œæ‰€ä»¥ç»§ç»­ ï¼Œ example = bean[key][1]
                  searchIndex = keyEnd + PROPERTY_KEY_SUFFIX.length();
               }
            }
         }
      
         // [6] åˆ›å»ºtoken
         PropertyTokenHolder tokens = new PropertyTokenHolder(actualName != null ? actualName : propertyName);
      
         // [7] keysä¸ä¸ºç©ºï¼Œ
         if (!keys.isEmpty()) {
            // è§„èŒƒåç§°ï¼Œè²Œä¼¼è¿™ä¸ªç”¨ä¸åˆ°
            tokens.canonicalName += PROPERTY_KEY_PREFIX +
                  StringUtils.collectionToDelimitedString(keys, PROPERTY_KEY_SUFFIX + PROPERTY_KEY_PREFIX) +
                  PROPERTY_KEY_SUFFIX;
            tokens.keys = StringUtils.toStringArray(keys);
         }
         return tokens;
      }
      ```

      è¿™ä¸ªç®—æ³•å¾ˆç®€å•ï¼Œå€¼å¾—å…³æ³¨çš„åœ°æ–¹æ˜¯ç”¨äºç¡®å®š `]`ä½ç½®çš„æ–¹æ³• `getPropertyNameKeyEnd`

      å› ä¸ºå½“ä¼ å…¥è¿›æ¥çš„ `nested` å€¼æ˜¯ `map[map[key]]` çš„æ—¶å€™ï¼Œ`springä¸æ”¯æŒè¿™ç§å†™æ³•` ï¼Œæˆ‘æ€ä¹ˆçŸ¥é“ï¼Ÿçœ‹ä¸‹é¢çš„æ–¹æ³•å®ç°ä½ å°±çŸ¥é“äº†ã€‚

      ```java
      private int getPropertyNameKeyEnd(String propertyName, int startIndex) {
         /**---------------------------------------------------------------------------
          * [DESC] å…¶ä½œç”¨ä¹Ÿå°±æ˜¯ç¡®è®¤ ] çš„ä½ç½®ï¼Œéœ€è¦è€ƒè™‘çš„é—®é¢˜æ˜¯
          * 1. beans[child[2]] é‚£ä¹ˆæˆ‘ä»¬åº”è¯¥å–æœ€å¤–å±‚çš„ ] çš„ä½ç½®
          * 2. å› ä¸º spring ä¸æ”¯æŒä¸Šé¢è¿™ç§å†™æ³•ï¼Œå®ƒä¼šæŠŠ child[2] å½“æˆå­—ç¬¦ä¸²ï¼Œå½“æˆbeansçš„key
          *----------------------------------------------------------------------------*/
         int unclosedPrefixes = 0;
         int length = propertyName.length();
         for (int i = startIndex; i < length; i++) {
            switch (propertyName.charAt(i)) {
               // [1] å¦‚æœé‡åˆ°äº† [ åˆ™ unclosedPrefixes++,ç”¨äºåˆ¤æ–­è¿›å…¥äº†å¤šå°‘å±‚çš„ [] 
               case PropertyAccessor.PROPERTY_KEY_PREFIX_CHAR:
                  // The property name contains opening prefix(es)...
                  unclosedPrefixes++;
                  break;
                  
                  // [2] å¦‚æœé‡åˆ°äº† ]
               case PropertyAccessor.PROPERTY_KEY_SUFFIX_CHAR:
                  // unclosedPrefixes == 0 è¯´æ˜è¿™æ˜¯æœ€å¤–å±‚çš„ ]
                  if (unclosedPrefixes == 0) {
                     // æœ€å¤–å±‚ç›´æ¥è¿”å›
                     // No unclosed prefix(es) in the property name (left) ->
                     // this is the suffix we are looking for.
                     return i;
                  }
                  else {
                     // å¦åˆ™ä¸æ˜¯æœ€å¤–å±‚çš„ ] ,unclosedPrefixed -- è¡¨ç¤ºé€€å‡ºä¸€å±‚ï¼Œç»§ç»­å¯»æ‰¾å¤–ä¸€å±‚çš„ ]
                     unclosedPrefixes--;
                  }
                  break;
            }
         }
         return -1;
      }
      ```

      å› ä¸ºè¿™ä¸ªæ–¹æ³•æ˜¯æ‹¿åˆ°æœ€å¤–å±‚ `]` çš„ä½ç½®ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬æ‹¿åˆ°çš„`key` ä¹Ÿåªèƒ½æ‹¿æœ€å¤–å±‚ï¼Œæ‰€ä»¥å³ä½¿ä½ æœ‰å¤šå±‚`key`ï¼Œå®ƒä¹Ÿåªè¯†åˆ«ä¸€å±‚, ä¾‹å¦‚ï¼š`beans[map[key]]` å®ƒåªèƒ½è¯†åˆ«å‡º `beans` æ˜¯ä¸€ä¸ª `map` ï¼Œè€Œ `map[key]` å½“æˆæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸º `beans ` çš„ä¸€ä¸ª `key` å¤„ç†

   2. æ ¹æ®`token`è·å–è¯¥å±æ€§çš„ `Instance`

      åœ¨ä¸Šé¢ è§£æä¸­ï¼Œæˆ‘ä»¬å·²ç»æ‹¿åˆ°äº†`token` ï¼Œæˆ‘ä»¬çŸ¥é“ `token` é‡Œé¢åŒ…å«äº†`å±æ€§å`å’Œ `keys` ï¼Œæ¥ä¸‹æ¥å°±èƒ½é€šè¿‡`å±æ€§å`æ‹¿åˆ°`å±æ€§å€¼äº†`

      ```java
       Object value = getPropertyValue(tokens);
      ```

      ```java
      protected Object getPropertyValue(PropertyTokenHolder tokens) throws BeansException {
         String propertyName = tokens.canonicalName;
         String actualName = tokens.actualName;
         // [1] ç›´æ¥è·å– handler,handlerç”¨äºè®¿é—®å±æ€§
         PropertyHandler ph = getLocalPropertyHandler(actualName);
      ```

      ä¸Šé¢æåˆ°è¿‡ï¼Œ`PropertyHandler` æ˜¯ç”¨äºè®¿é—®å±æ€§çš„ï¼ŒèŒè´£åˆ†ç¦»å˜›ï¼Œæ‰€ä»¥å†æ‹¿åˆ°`token` åï¼Œå°±å¯ä»¥è·å– `Handler`äº†ã€‚è¿™ä¸ªæ–¹æ³•çš„å®ç°æ˜¯åœ¨`BeanWrapperImpl#getLocalPropertyHandler`ä¸­å®ç°çš„ã€‚

      ```java
      protected BeanPropertyHandler getLocalPropertyHandler(String propertyName) {
         // [1] å®ç°å¾ˆç®€å•ï¼Œç›´æ¥ä»ç¼“å­˜è·å–å±æ€§æè¿°ç¬¦
         PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(propertyName);
         return (pd != null ? new BeanPropertyHandler(pd) : null);
      }
      ```

      å–„ç”¨ç¼“å­˜ï½:happy:  ï¼Œè¿˜è®°å¾— `getCachedIntrospectionResults` è¿™ä¸ªæ–¹æ³•ä¹ˆï¼Œä»`ç¼“å­˜`æˆ–è€…ä»`çº¿ç¨‹ä¸Šä¸‹æ–‡ç±»åŠ è½½å™¨`

      æ‹¿åˆ° `BeanInfo`ï¼Œç°åœ¨æˆ‘ä»¬éœ€è¦åˆ° `BeanInfo -> PropertyDescriptor` 

      æœ€åæˆ‘ä»¬å°±æ‹¿åˆ°äº† `Handler`ï¼Œè¿™ä¸ª`Handler`çš„å®ç°ç±»æ˜¯ `BeanPropertyHandler` 

      å›åˆ°ä¸Šé¢çš„æ–¹æ³•ï¼Œç°åœ¨å·²ç»æœ‰äº† `Handler` 

      ```java
      protected Object getPropertyValue(PropertyTokenHolder tokens) throws BeansException {
         String propertyName = tokens.canonicalName;
         String actualName = tokens.actualName;
         // [1] ç›´æ¥è·å– handler,handlerç”¨äºè®¿é—®å±æ€§
         PropertyHandler ph = getLocalPropertyHandler(actualName);
      
         // å±æ€§æ˜¯å¦å­˜åœ¨æˆ–è€…ä¸å¯è¯»
         if (ph == null || !ph.isReadable()) {
            throw new NotReadablePropertyException(getRootClass(), this.nestedPath + propertyName);
         }
         try {
      
            // [2] ç›´æ¥è°ƒç”¨ propertyHandle#getValue è·å–å±æ€§å€¼
            Object value = ph.getValue();
      ```

      è·Ÿ `#getValue`

      ```java
      public Object getValue() throws Exception {
         // [1] ä»å±æ€§æè¿°ç¬¦ä¸­è·å– Method
         final Method readMethod = this.pd.getReadMethod();
      
         // [2] æ¸…é™¤æ–¹æ³•æƒé™ï¼Œç„¶åç›´æ¥è°ƒç”¨getæ–¹æ³•
         if (System.getSecurityManager() != null) {
            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
               ReflectionUtils.makeAccessible(readMethod);
               return null;
            });
            try {
               return AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () ->
                     readMethod.invoke(getWrappedInstance(), (Object[]) null), acc);
            }
            catch (PrivilegedActionException pae) {
               throw pae.getException();
            }
         }
         else {
            ReflectionUtils.makeAccessible(readMethod);
            return readMethod.invoke(getWrappedInstance(), (Object[]) null);
         }
      }
      ```

      ç†Ÿæ‚‰å§ï¼Œä» `PropertyDescriptor`æ‹¿åˆ° `readMethod`ï¼Œç„¶ååå°„è°ƒç”¨ä¸€ä¸‹å°± ğŸ‘Œ

      ä½†è¿™æ²¡æœ‰ç»“æŸï¼Œå› ä¸ºè¿˜è¦å¤„ç† `keys`å‘¢ï¼Œç»§ç»­è¿½`getPropertyValue`

      ```java
      protected Object getPropertyValue(PropertyTokenHolder tokens) throws BeansException {
         String propertyName = tokens.canonicalName;
         String actualName = tokens.actualName;
         // [1] ç›´æ¥è·å– handler,handlerç”¨äºè®¿é—®å±æ€§
         PropertyHandler ph = getLocalPropertyHandler(actualName);
      
         // å±æ€§æ˜¯å¦å­˜åœ¨æˆ–è€…ä¸å¯è¯»
         if (ph == null || !ph.isReadable()) {
            throw new NotReadablePropertyException(getRootClass(), this.nestedPath + propertyName);
         }
         try {
      
            // [2] ç›´æ¥è°ƒç”¨ propertyHandle#getValue è·å–å±æ€§å€¼
            Object value = ph.getValue();
      
            // [3] è¿™é‡Œè¿˜æ˜¯å¾ˆç†Ÿæ‚‰ï¼Œå°±æ˜¯åˆ¤æ–­tokenæ˜¯å¦å­˜åœ¨ï¼Œç„¶åå¦‚æœæ”¯æŒé›†åˆç±»å‹
            // å¦‚æœå±æ€§å€¼ä¸ºnullï¼Œåˆ™new ä¸€ä¸ªé›†åˆç»™å®ƒ
            // å¦‚æœä¸æ”¯æŒé›†åˆç±»å‹ï¼Œé‚£ä¹ˆ over~
            if (tokens.keys != null) {
               if (value == null) {
                  if (isAutoGrowNestedPaths()) {
                     value = setDefaultValue(new PropertyTokenHolder(tokens.actualName));
                  }
                  else {
                     throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,
                           "Cannot access indexed value of property referenced in indexed " +
                                 "property path '" + propertyName + "': returned null");
                  }
               }
               StringBuilder indexedPropertyName = new StringBuilder(tokens.actualName);
               // [4] ä¸‹é¢æ˜¯é‡å¤´æˆï¼Œä¹Ÿå°±æ˜¯å¤„ç†é›†åˆç±»å‹çš„å±æ€§
               for (int i = 0; i < tokens.keys.length; i++) {
                  String key = tokens.keys[i];
                  if (value == null) {
                     throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName,
                           "Cannot access indexed value of property referenced in indexed " +
                                 "property path '" + propertyName + "': returned null");
                  }
      
                  // ç±»å‹æ˜¯ Array
                  else if (value.getClass().isArray()) {
                     int index = Integer.parseInt(key);
                     value = growArrayIfNecessary(value, index, indexedPropertyName.toString());
                     value = Array.get(value, index);
                  }
                  // ç±»å‹æ˜¯ List
                  else if (value instanceof List) {
                     int index = Integer.parseInt(key);
                     List<Object> list = (List<Object>) value;
                     growCollectionIfNecessary(list, index, indexedPropertyName.toString(), ph, i + 1);
                     value = list.get(index);
                  }
                  // ç±»å‹æ˜¯ Set
                  else if (value instanceof Set) {
                     // Apply index to Iterator in case of a Set.
                     Set<Object> set = (Set<Object>) value;
                     int index = Integer.parseInt(key);
                     if (index < 0 || index >= set.size()) {
                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName,
                              "Cannot get element with index " + index + " from Set of size " +
                                    set.size() + ", accessed using property path '" + propertyName + "'");
                     }
                     Iterator<Object> it = set.iterator();
                     for (int j = 0; it.hasNext(); j++) {
                        Object elem = it.next();
                        if (j == index) {
                           value = elem;
                           break;
                        }
                     }
                  }
                  // ç±»å‹æ˜¯ Map
                  else if (value instanceof Map) {
                     Map<Object, Object> map = (Map<Object, Object>) value;
                     Class<?> mapKeyType = ph.getResolvableType().getNested(i + 1).asMap().resolveGeneric(0);
                     // IMPORTANT: Do not pass full property name in here - property editors
                     // must not kick in for map keys but rather only for map values.
                     TypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);
                     Object convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);
                     value = map.get(convertedMapKey);
                  }
                  indexedPropertyName.append(PROPERTY_KEY_PREFIX).append(key).append(PROPERTY_KEY_SUFFIX);
               }
            }
            return value;
         }
      }
      ```

      ä¸Šé¢å¯ä»¥çœ‹åˆ°ï¼Œåœ¨è·å–å±æ€§å€¼åï¼Œéœ€è¦å¤„ç†`keys`çš„é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯è¦æ”¯æŒé›†åˆï¼Œå¯ä»¥çœ‹å‡º `spring` æ”¯æŒ

      + Array
      + List
      + Set
      + Map

      å››ç§é›†åˆç±»å‹

   3. å°†`Instance` åŒ…è£…æˆ `AbstractNestablePropertyAccessor`

      è¿™ä¸ªæ²¡ä»€ä¹ˆå¥½è§£é‡Šçš„ï¼Œ`new` ä¸€ä¸‹ï¼Œç„¶åç»™æˆå‘˜å˜é‡èµ‹å€¼

5. 

    













